#!/usr/bin/env python3

# pylint: disable=invalid-name, ungrouped-imports, too-many-lines, missing-docstring, line-too-long

import os
import re
import sys
import json
import subprocess
import tempfile
import atexit
import argparse
import logging
import errno
import textwrap
import random
import shlex
import io
from subprocess import STDOUT, PIPE, DEVNULL, Popen
from datetime import datetime

import urwid

# #############################################################################
# constants
# #############################################################################

DATA_FOLDER = os.getenv('XDG_DATA_HOME'  , os.path.expanduser('~/.local/share'))
CFG_FOLDER  = os.getenv('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))

SCLI_DATA_FOLDER  = os.path.join(DATA_FOLDER, 'scli')
SCLI_HISTORY_FILE = os.path.join(SCLI_DATA_FOLDER, 'history')
SCLI_CFG_FILE     = os.path.join(CFG_FOLDER, 'sclirc')
SCLI_LOG_FILE     = os.path.join(SCLI_DATA_FOLDER, 'log')

# #############################################################################
# coloring stuff
# #############################################################################

# TODO: make costumizable

PALETTE = [('normal', '', ''),
           ('box_normal', '', ''),
           ('box_focused', 'dark blue', ''),
           ('bold', 'bold', ''),
           ('italic', 'italics', ''),
           ('strikethrough', 'strikethrough', ''),
           ('bolditalic', 'italics,bold', ''),
           ('reversed', 'standout', ''),
           ('selected', 'bold', ''),
           ('underline', 'underline', '')]

PALETTE_NO_ITALICS = [
           ('normal', '', ''),
           ('box_normal', '', ''),
           ('box_focused', 'dark blue', ''),
           ('bold', 'bold', ''),
           ('italic', 'bold', ''),
           ('strikethrough', 'strikethrough', ''),
           ('bolditalic', 'bold', ''),
           ('reversed', 'standout', ''),
           ('selected', 'bold', ''),
           ('underline', 'underline', '')]

LIST_FOCUS_MAP = { None: 'reversed',
                   'normal': 'reversed',
                   'bold'  : 'reversed',
                   'italic': 'reversed',
                   'strikethrough': 'reversed',
                   'bolditalic': 'reversed'}

FORMAT_MAP = {'/': 'italic',
              '*': 'bold',
              '~': 'strikethrough',
              '_': 'underline'}

def ibtxt(txt):
    return ('bolditalic', txt)

def ntxt(txt):
    return ('normal', txt)

def btxt(txt):
    return ('bold', txt)

def itxt(txt):
    return ('italic', txt)

def to_txt(txt):
    if isinstance(txt, str):
        return txt
    elif isinstance(txt, tuple):
        return txt[1]
    else:
        return ''.join([to_txt(t) for t in txt])

# #############################################################################
# utility
# #############################################################################

def get_urls(txt):
    return re.findall(r'(https?://[^\s]+)', txt)

def mk_call(cmd, rmap=None, disown=False, use_pipe=True):
    if not rmap:
        rmap = {}

    for key, val in rmap.items():
        cmd = cmd.replace(key, val)

    if disown:
        subprocess.Popen(cmd, shell=True, stdout=DEVNULL, stderr=DEVNULL, preexec_fn=os.setpgrp)
    else:
        if use_pipe:
            pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        else:
            pipe = subprocess.Popen(cmd, shell=True)

        out, err = pipe.communicate()
        logging.info('mk_call:%s', cmd)
        try:
            if pipe.returncode == 0:
                logging.info('mk_call:exit_0:%s:%s', cmd, out.decode('utf-8'))
            else:
                logging.critical('mk_call:exit_%d:%s:%s', pipe.returncode, cmd, err.decode('utf-8'))
        except AttributeError:
            pass

        return out


class ObservableConfig:
    signals = ['changed']

    def __init__(self, cfg_obj):
        self._cfg_obj = cfg_obj

    def __getattr__(self, name):
        return getattr(self._cfg_obj, name)

    def __setattr__(self, name, value):
        if name != '_cfg_obj' and hasattr(self._cfg_obj, name):
            setattr(self._cfg_obj, name, value)
            urwid.emit_signal(self, 'changed', name, value)
        else:
            super().__setattr__(name, value)

urwid.register_signal(ObservableConfig, ObservableConfig.signals)

# #############################################################################
# signal utility
# #############################################################################

def hash_contact(x):
    h = ''
    if x.get('number'):
        h = x['number']
    elif x.get('groupId'):
        h = x['groupId']
    else:
        logging.critical('hash_contact:No number or groupId')
    return h

def get_contact_name(x):
    if not x:
        logging.critical('get_contact_name:empty sender')
        return "NULL"

    name = x.get('name')
    if name or name.strip(' ') != '':
        return name

    number = x.get('number')
    if number:
        return number

    return "ERR"

def get_contact_color(x):
    color = x.get('color')
    if color or color.strip(' ') != '':
        return color

    return 'white'

def is_contact_group(contact):
    return 'groupId' in contact

def is_envelope_outgoing(envelope):
    try:
        envelope['target']
        return True
    except KeyError:
        return False

def is_envelope_group_message(envelope):
    try:
        envelope['dataMessage']['groupInfo']['groupId']
        return True
    except (KeyError, TypeError):
        return False

def get_envelope_msg(envelope):
    try:
        return envelope['dataMessage']['message']
    except (KeyError, TypeError):
        return None

def get_envelope_contact(envelope, signal):
    x = None
    if envelope.get('target'):
        x = envelope['target']
    elif is_envelope_group_message(envelope):
        x = get_envelope_group_id(envelope)
    else:
        x = envelope['source']

    contact = signal.get_contact(x)
    if not contact:
        logging.critical('NULL_CONTACT:%s', envelope)

    return contact

def get_envelope_group_id(envelope):
    try:
        return envelope['dataMessage']['groupInfo']['groupId']
    except (KeyError, TypeError):
        return None

def get_envelope_attachments(envelope):
    try:
        return envelope['dataMessage']['attachments']
    except e:
        logger.debug('except in get_envelope_attachments for envelope: %s', envelope)
        logger.exception(e)
        return []

def get_attachment_name(attachment):
    try:
        return attachment['filename']
    except (KeyError, TypeError):
        return os.path.basename(attachment)

def get_attachment_type(attachment):
    try:
        return attachment['contentType']
    except (KeyError, TypeError):
        return None

def get_backend_desc(cfg):
    class SignalCLIlayout:
        def __init__(self, name, bases):
            self.base_path = None
            self.name = name
            for base in bases:
                if os.path.exists(base):
                    self.base_path = base
                    break
            if not self.base_path:
                raise Exception(self.name + ' base directory not found')
            self.data_path = os.path.join(self.base_path, 'data')
            self.attachments_path = os.path.join(self.base_path, 'attachments')

        def list_users(self):
            return [x for x in os.listdir(self.data_path)
                      if os.path.isfile(os.path.join(self.data_path, x))]

        def user_path(self, user):
            path = os.path.join(self.data_path, user)
            if os.path.exists(path):
                return path
            raise Exception(user + ' does not exists!')

        def user_data_path(self, user):
            return os.path.join(self.base_path, user + '.d')

    if cfg.signald:
        SIGNALD_FOLDER          = os.path.join(CFG_FOLDER, 'signald')
        return SignalCLIlayout('signald', [SIGNALD_FOLDER])
    else:
        SIGNALCLI_FOLDER        = os.path.join(DATA_FOLDER, 'signal-cli')
        SIGNALCLI_LEGACY_FOLDER = os.path.join(CFG_FOLDER, 'signal')
        return SignalCLIlayout('signal-cli',
                               [SIGNALCLI_FOLDER, SIGNALCLI_LEGACY_FOLDER])

def get_attachment_path(cfg, attachment):
    if isinstance(attachment, dict):
        path = os.path.join(get_backend_desc(cfg).attachments_path, str(attachment['id']))
    elif isinstance(attachment, str):
        path = attachment
    if os.path.exists(path):
        return path

# #############################################################################
# ui utility
# #############################################################################

# related: https://github.com/urwid/urwid/pull/154
def update_focus(command, order):
    try:
        deltas = {'next selectable': +1, 'prev selectable': -1}
        delta = deltas[command]
        for k, v in enumerate(order):
            if all([x.focus_position == v[x] for x in v]):
                pos = order[(k+delta)%len(order)]
                for x in pos:
                    x.focus_position = pos[x]
                return True
    except KeyError:
        pass
    return False

class FocusableText(urwid.AttrMap):
    def __init__(self, markup, keypress = lambda size, key : key, **kwargs):
        text = urwid.Text(markup, **kwargs)
        text._selectable = True
        text.keypress = keypress
        super().__init__(text, None, focus_map=LIST_FOCUS_MAP)

class NiceBox(urwid.AttrMap):
    def __init__(self, w, title=''):
        box = urwid.AttrMap(urwid.LineBox(urwid.AttrMap(w, 'normal'),
                                          title_align='center', title=title),
                            'box_normal')
        super().__init__(box, None, focus_map={'box_normal':'box_focused'})

CURSOR_FIRST = 'scli cursor first'
CURSOR_LAST  = 'scli cursor last'

class VimListBox(urwid.ListBox):

    def __init__(self, body):
        self._body = None
        self._original_render = self.render
        super().__init__(body)
        self._command_map['j'] = urwid.CURSOR_DOWN
        self._command_map['k'] = urwid.CURSOR_UP
        self._command_map['g'] = CURSOR_FIRST
        self._command_map['G'] = CURSOR_LAST

    @property
    def body(self):
        return super().body

    # workaround missing signal re-connection on .body change in urwid.ListBox
    @body.setter
    def body(self, body):
        old = self.body
        if body is not old and old:
            try:
                urwid.disconnect_signal(old, 'modified', super()._invalidate)
            except NameError:
                pass
        super()._set_body(body)
        if body is not old and body:
            try:
                self.render = self._original_render
                urwid.connect_signal(body, 'modified', super()._invalidate)
            except NameError:
                # our list walker has no modified signal so we must not
                # cache our canvases because we don't know when our
                # content has changed
                self.render = urwid.widget.nocache_widget_render_instance(self)

    def _focus_first_selectable(self, reverse = False):
        for pos in self.body.positions(reverse):
            if self.body[pos].selectable():
                self.body.set_focus(pos)
                break

    def focus_first(self):
        self._focus_first_selectable()

    def focus_last(self):
        self._focus_first_selectable(True)

    def keypress(self, size, key):
        # override the default, which for CURSOR_MAX_{LEFT,RIGHT} does not take
        # child.selectable() into account; we do this here instead of __init__,
        # since CommandMap is not iterable
        if self._command_map[key] == urwid.CURSOR_MAX_LEFT:
            self._command_map[key] = CURSOR_FIRST
        elif self._command_map[key] == urwid.CURSOR_MAX_RIGHT:
            self._command_map[key] = CURSOR_LAST
        key = super().keypress(size, key)
        if self._command_map[key] == CURSOR_FIRST:
            self.focus_first()
            key = None
        elif self._command_map[key] == CURSOR_LAST:
            self.focus_last()
            key = None
        elif key == 'r':
            pass # TODO: refresh
        return key


# #############################################################################
# clipboard
# #############################################################################

class clip:
    mime_order = ['image/png', 'image/jpeg', 'image/jpg', 'text/uri-list']

    @staticmethod
    def xrun(mime):
        p = Popen(['xclip', '-selection', 'clipboard', '-t', mime, '-o'], stdout=PIPE, stderr=PIPE)
        out, err = p.communicate()
        return out

    @staticmethod
    def xrun_lines(mime):
        out = clip.xrun(mime)
        if out:
            return out.decode('utf-8').split('\n')

    @staticmethod
    def xfiles():
        out = clip.xrun_lines('TARGETS')

        for otype in out:
            for mtype in clip.mime_order:
                if mtype == otype:
                    if mtype.startswith('image/'):
                        content = clip.xrun(mtype)
                        suffix = '.' + mtype.split('/')[1]
                        tmp = tempfile.NamedTemporaryFile(mode='w+b', suffix=suffix, delete=False)
                        tmp.write(content)
                        tmp.flush()
                        tmp.close()
                        return [tmp.name]
                    elif mtype == 'text/uri-list':
                        content = clip.xrun_lines(mtype)
                        return [x.replace('file://', '') for x in content[1:]]

    @staticmethod
    def xput(txt):
        if txt is None:
            return

        p = Popen(['xclip', '-selection', 'clipboard'], stdout=PIPE, stderr=PIPE, stdin=PIPE)
        p.stdin.write(bytes(txt, 'utf-8'))
        p.stdin.close()
        p.wait()

    @staticmethod
    def put(state, txt):
        cmd = state.cfg.clipboard_put_command
        if cmd == "":
            return clip.xput(txt)

        return mk_call(cmd, {'%s': txt})

    @staticmethod
    def files(state):
        cmd = state.cfg.clipboard_get_command
        if cmd == "":
            return clip.xfiles()

        return mk_call(cmd).split('\n')

# #############################################################################
# commands
# #############################################################################

class Commands:
    def __init__(self, state):
        self.state = state
        self.map = [(['attach', 'a'], self.attach),
                    (['edit', 'e'], self.external_edit),
                    (['attachClip', 'c'], self.attach_clip),
                    (['openAttach', 'o'], self.open_last_attach),
                    (['openUrl', 'u'], self.open_last_url),
                    (['toggleNotifications', 'n'], self.toggle_notifications),
                    (['toggleAutohide', 'h'], self.toggle_autohide),
                    (['quit', 'q'], self.quit)]

    def exec(self, cmd, args):
        for (abbrvs, fn) in self.map:
            if cmd in [abbrv.lower() for abbrv in abbrvs]:
                fn(args)
                return

    @staticmethod
    def _shell_parse_first(string):
        sio = io.StringIO(string)
        lex = shlex.shlex(sio, posix=True)
        lex.whitespace_split = True
        fst = lex.get_token()
        if fst == lex.eof:
            return None
        return (fst, sio.read())

    def external_edit(self, arg):
        parsed = self._shell_parse_first(arg)
        if parsed and len(parsed[1]) == 0 and (parsed[0].startswith("/") or parsed[0].startswith("~/")):
            # parsed[0] is a path, treat it like the shell does
            msg_file_path = os.path.expanduser(parsed[0])
        else:
            # either no arguments or more than one, treat original string as
            # initial content of edit text file
            msg_file_path = tempfile.NamedTemporaryFile(suffix='.md', delete=False).name
            if arg:
                with open(msg_file_path, "w") as msg_file:
                    msg_file.write(arg)

        self.state.loop.stop()
        mk_call(self.state.cfg.editor_command + " " + msg_file_path, use_pipe=False)
        print('Please wait...')
        self.state.loop.start()

        if os.path.exists(msg_file_path):
            with open(msg_file_path, 'r') as msg_file:
                msg = msg_file.read().strip()
                self.state.send_message(msg)

    def open_file(self, path): # TODO: does not belong here
        if os.path.exists(path):
            if isinstance(path, dict):
                mk_call(self.state.cfg.open_command, path, True)
            mk_call(self.state.cfg.open_command, {'%u': path}, True)

    def attach(self, arg):
        # first argument is a path, treat it like the shell does
        try:
            attachment, message = self._shell_parse_first(arg)
            self.state.send_message(message, [attachment])
        except TypeError:
            self.state.set_error(':attach takes at least one argument.')

    def attach_clip(self, arg):
        files = clip.files(self.state)

        if files:
            self.state.send_message(arg, files)
        else:
            self.state.set_notification('Clipboard is empty.')

    def open_attach(self, envelope):
        result = False
        attachments = get_envelope_attachments(envelope)
        for attachment in attachments:
            file_path = get_attachment_path(self.state.cfg, attachment)
            if file_path:
                self.open_file(file_path)
                result = True

        return result

    def open_last_attach(self, _):
        for txt in self.state.current_chat[::-1]:
            if self.open_attach(txt.envelope):
                return

    def open_single_url(self, url): # TODO: does not belong here
        mk_call(self.state.cfg.open_command, {'%u': url}, True)

    def open_url(self, envelope): # TODO: does not belong here
        txt = get_envelope_msg(envelope)
        urls = get_urls(txt)
        if urls:
            self.open_single_url(urls[0])
            return True
        return False

    def open_last_url(self, _):
        for txt in self.state.current_chat[::-1]:
            if self.open_url(txt.envelope):
                return

    def toggle_notifications(self, _):
        self.state.cfg.enable_notifications = not self.state.cfg.enable_notifications
        notif = 'Desktop notifications are '
        if self.state.cfg.enable_notifications:
            notif = notif + 'ON'
        else:
            notif = notif + 'OFF'
        self.state.set_notification(notif + '.')

    def toggle_autohide(self, _):
        self.state.cfg.contacts_autohide = not self.state.cfg.contacts_autohide

    def send_notification(self, sender, message): # TODO: does not belong here
        if self.state.cfg.enable_notifications:
            mk_call(self.state.cfg.notification_command, {'%s': sender, '%m': message})

    def quit(self, _):
        raise urwid.ExitMainLoop()

# #############################################################################
# signal
# #############################################################################

class BackgroundProcess:
    def __init__(self, proc, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._proc = proc
        atexit.register(self._kill_wait)

    @property
    def proc(self):
        exitcode = self._proc.poll()
        if exitcode is not None:
            raise Exception('background process has died already with code ' + str(exitcode))
        return self._proc

    def _kill_wait(self):
        logging.debug('BackgroundProcess._kill_wait: terminating background process.')
        self._proc.terminate()
        self._proc.wait()

class JsonLineReaderMixin:
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._buffer = b''

    def _daemon_handler(self, line):
        line = self._buffer + line
        lines = line.split(b'\n')
        if lines[-1] != b'':
            # Not a complete message. Store in buffer
            self._buffer = lines[-1]
        else:
            self._buffer = b''

        # The last item is either empty or an incomplete message, so we don't process it
        for line in lines[:-1]:
            if not line.strip():
                continue

            try:
                e = json.loads(line)
                logging.debug('_daemon_handler: received json line: %s', line)
                # urwid.emit_signal(self, 'receive_message', e['envelope'])
                self._json_handler(e)
            except json.decoder.JSONDecodeError as e:
                logging.error('_daemon_handler: error parsing as JSON: %s', line)
                logging.exception(e)
                # TODO: display error to user
                continue
        self.proc

class SignalCLIDaemon(BackgroundProcess, JsonLineReaderMixin):
    def __init__(self, user, loop, emit_obj):
        self.user = user
        self._emit_obj = emit_obj
        fd = loop.watch_pipe(self._daemon_handler)
        super().__init__(Popen(['signal-cli', '-u', user, 'daemon', '--json'],
                               stdout=fd, stderr=STDOUT, close_fds=True))

    def _json_handler(self, e):
        urwid.emit_signal(self._emit_obj, 'receive_message', e['envelope'])

    def send_message(self, contact, message, attachments=None):
        if not attachments:
            attachments = []

        attachment_paths = [os.path.expanduser(attachment) for attachment in attachments]
        if not all([os.path.exists(attachment_path) for attachment_path in attachment_paths]):
            logging.warning('SignalCLI: send_message: Attached file(s) does not exist.')
            return

        if not contact.get('number'):
            args = ['signal-cli', '--dbus', 'send', '--message', message]
            target = None
            if contact.get('number'):
                target = contact['number']
            else:
                target = contact['groupId']
                args.append('--group')
            args.append(target)

            if attachment_paths:
                args.append('--attachment')
            for attachment_path in attachment_paths:
                args.append(attachment_path)
        else:
            # didn't figure out how to send to a group via dbus, yet
            target = contact['number']
            args = ['dbus-send', '--session', '--dest=org.asamk.Signal',
                    '--type=method_call', '/org/asamk/Signal',
                    'org.asamk.Signal.sendMessage', 'string:' + message,
                    'array:string:' + ','.join(attachment_paths),
                    'array:string:' + target]

        p = Popen(args, stdout=PIPE, stderr=PIPE)
        _out, error = p.communicate()
        if p.returncode != 0:
            logging.error('send_message: exit code=%d:err=%s', p.returncode, error)
            # https://github.com/AsamK/signal-cli/issues/73
            # return

        ts = datetime.now().timestamp()
        envelope = {'source':self.user,
                    'target': target,
                    'timestamp': ts,
                    'dataMessage': {'message': message,
                                    'attachments': attachments,
                                    'timestamp': ts}}

        urwid.emit_signal(self._emit_obj, 'send_message', envelope)

def signalcli_daemon(user, loop, emit_obj):
    return SignalCLIDaemon(user, loop, emit_obj)


# some code from https://gitlab.com/stavros/pysignald/blob/master/signald/main.py
class SignaldIO(BackgroundProcess, JsonLineReaderMixin):
    def __init__(self, user, loop, emit_obj, cmd : list):
        self.user = user
        self._emit_obj = emit_obj
        fd = loop.watch_pipe(self._daemon_handler)
        super().__init__(Popen(cmd, stdin=PIPE, stdout=fd, stderr=STDOUT, close_fds=True))
        # send messages to self.proc.stdin
        self.proc.stdin.write(json.dumps({
            "type": "subscribe",
            "username": user
        }).encode("utf8") + b"\n")
        self.proc.stdin.flush()

    def _kill_wait(self):
        self.proc.stdin.write(json.dumps({
            "type": "unsubscribe",
            "username": self.user
        }).encode("utf8") + b"\n")
        self.proc.stdin.flush()
        super()._kill_wait()

    def _json_handler(self, message):
        if message.get("type") != "message" or (
            not message["data"]["isReceipt"] and message["data"].get("dataMessage") is None
        ):
            # If the message type isn't "message", or if it's a weird message whose
            # purpose I don't know, return. I think the weird message is a typing
            # notification.
            logging.warning("can't handle 'weird message': %s", message)
        else:
            urwid.emit_signal(self._emit_obj, 'receive_message', message['data'])

    def _get_id(self):
        "Generate a random ID."
        return "".join(random.choice("abcdefghijklmnopqrstuvwxyz0123456789") for _ in range(10))

    def _send_command(self, payload: dict):
        s = self.proc.stdin
        msg_id = self._get_id()
        payload["id"] = msg_id
        logging.debug('SignaldIO._send_command: %s', payload)
        s.write(json.dumps(payload).encode("utf8") + b"\n")
        s.flush()

        #if not block:
        #    return
        #
        #response = s.recv(4 * 1024)
        #for line in response.split(b"\n"):
        #    if msg_id.encode("utf8") not in line:
        #        continue
        #
        #    data = json.loads(line)
        #
        #    if data.get("id") != msg_id:
        #        continue
        #
        #    if data["type"] == "unexpected_error":
        #        raise ValueError("unexpected error occurred")

    def send_message(self, recipient: str, text: str, attachments = None) -> None:
        """
        Send a message.

        recipient: The recipient's phone number, in E.123 format.
        text:      The text of the message to send.
        """
        if attachments is None:
            attachments = []
        payload = {
            "type": "send",
            "username": self.user,
            "recipientNumber": recipient['number'],
            "messageBody": text,
            "attachments": [{'filename': os.path.abspath(f)} for f in attachments],
        }
        self._send_command(payload)

        ts = datetime.now().timestamp()
        envelope = {'source':self.user,
                    'target': recipient['number'],
                    'timestamp': ts,
                    'dataMessage': {'message': text,
                                    'attachments': attachments,
                                    'timestamp': ts}}
        urwid.emit_signal(self._emit_obj, 'send_message', envelope)

def signald_socat(user, loop, emit_obj, socket_path):
    return SignaldIO(user, loop, emit_obj, ['socat', 'unix-client:' + socket_path, 'stdio'])

def signald_netcat_openbsd(user, loop, emit_obj, socket_path):
    return SignaldIO(user, loop, emit_obj, ['nc', '-U', socket_path])


class Signal:
    signals = ['receive_message', 'send_message']

    def __init__(self, be_desc, user):
        self.user = user
        self._data = None
        self._buffer = b''
        self._path = be_desc.user_path(user)
        self.reload_data()

    def reload_data(self):
        with open(self._path) as f:
            self._data = json.load(f)

    def contacts(self):
        return list(filter(lambda x: bool(get_contact_name(x).strip(' ')),
                           self._data['contactStore']['contacts']))

    def groups(self):
        # Need to filter out any groups that where "active" == false
        return list(filter(lambda a: bool(a['active']),
                    (filter(lambda n: bool(n['name'].strip(' ')),
                     self._data["groupStore"]['groups']))))

    def get_contact(self, number_or_id):
        for contact in self.contacts():
            if contact['number'] == number_or_id:
                return contact

        for group in self.groups():
            if group['groupId'] == number_or_id:
                return group

urwid.register_signal(Signal, Signal.signals)

# #############################################################################
# ContactsWindow
# #############################################################################

class ContactsWindow(VimListBox):
    signals = ['notify_count_changed']

    def __init__(self, state):
        self.state = state
        self.notify_count = 0

        super().__init__(urwid.SimpleFocusListWalker([]))
        self.update_contacts()

        urwid.connect_signal(self.state.signal, 'receive_message', self.on_receive_message)
        urwid.connect_signal(self.state, 'current_contact_changed', self.on_current_contact_changed)

    def set_contact_notify_count(self, w, count):
        if hasattr(w, 'notify_count'):
            self.notify_count += count - w.notify_count
        else:
            self.notify_count += count

        urwid.emit_signal(self, 'notify_count_changed', self.notify_count)

        w.notify_count = count
        if count > 0:
            w.original_widget.set_text([('bold', '({}) '.format(w.notify_count)),
                                        get_contact_name(w.contact)])
        else:
            w.original_widget.set_text(get_contact_name(w.contact))

    def on_current_contact_changed(self, _old, _current, _focus=False):
        if _current:
            self.set_contact_notify_count(self.focus, 0)
        if _old != _current:
            for w in self.body:
                try:
                    if _old and w.contact == _old:
                        w.set_attr_map({})
                    elif _current and w.contact == _current:
                            w.set_attr_map({None: 'selected'})
                except AttributeError:
                    pass

    def on_receive_message(self, envelope):
        contact = get_envelope_contact(envelope, self.state.signal)
        has_msg = get_envelope_msg(envelope)
        if contact == self.state.current_contact or not has_msg:
            return

        for w in self.body:
            if w.contact == contact:
                self.set_contact_notify_count(w, w.notify_count + 1)
                return

    def update_contacts(self):
        def adorn(w, c = None):
            w.contact = c
            w.notify_count = 0
            return w
        def mk_contact(x):
            # we want to "select" and interact with these Text widgets
            def keypress(size, key):
                if key in ('enter', 'l'):
                    self.state.set_current_contact(x, key == 'enter')
                elif key == 'u':
                    self.state.set_current_contact(None, False)
                else:
                    return key
                return None
            return adorn(FocusableText(get_contact_name(x), keypress), x)

        try:
            pre_focus = self.focus.contact
        except AttributeError:
            pre_focus = None
        header = lambda lbl: map(adorn,
                             (urwid.Divider('-'),
                              urwid.Text(('bold', '~~ ' + lbl + ' ~~'), align='center'),
                              urwid.Divider('-')))
        self.body[:] = [
            *header('Groups'),
            *map(mk_contact, self.state.signal.groups()),
            *header('Contacts'),
            *map(mk_contact, self.state.signal.contacts()),
        ]
        if not pre_focus:
            self.focus_first()
        else:
            try:
                self.focus_position = map   (lambda n, am: n,
                                      filter(lambda n, am: am.contact == pre_focus,
                                      enumerate(self.body)))[0]
            except IndexError:
                self.focus_first()

# #############################################################################
# ChatWindow
# #############################################################################

class ChatWindow(urwid.Pile):

    # #########################################################################
    # Editor; handling
    # - a mode (None or any single character in mode_map's keys) given by the
    #   first entered symbol ('backspace' resets to None):
    #   - the current mode is tracked and available to signals,
    #   - an 'editor_mode_changed' signal is fired on mode changes
    #   - the caption is changed according to mode_map's values
    # - in mode None, 'enter' signals 'activate' + resets text if at end of
    #   text and no preceeding '\\' else insert new-line
    # - other modes, 'enter' just signals 'activate' + reset
    # #########################################################################

    class Editor(urwid.Edit):
        signals = [urwid.ACTIVATE, 'editor_mode_changed']

        # mode_map is a mapping from 'key' (as in keypress(size, key)) to
        # a text markup suitable for the caption of an urwid.Edit.
        # It must include 'None' for the default mode and cannot include 'enter'
        # as it interferes with the line-break logic.
        def __init__(self, mode_map = {None: ('bold', '> ')}):
            self._mode = None
            self._mode_map = mode_map
            super().__init__(self._mode_map[self._mode], multiline=True)
            self._command_map['meta left'] = 'word left'
            self._command_map['meta right'] = 'word right'

        @property
        def mode(self):
            return self._mode

        @mode.setter
        def mode(self, new):
            old = self._mode
            self._mode = new
            if not old == new:
                self.set_caption(self._mode_map[new])
                urwid.emit_signal(self, 'editor_mode_changed', old, new)

        def keypress(self, size, key):
            if key == 'enter':
                send = True
                if not self.mode:
                    send = False
                    if self.edit_pos == len(self.edit_text):
                        if self.edit_pos > 0 and self.edit_text[self.edit_pos-1] == '\\':
                            super().keypress(size, 'backspace')
                        else:
                            send = True
                if send:
                    urwid.emit_signal(self, urwid.ACTIVATE, self.mode, self.edit_text)
                    self.mode = None
                    self.set_edit_text('')
                    return None

            mode = self.mode
            if key == 'esc' or self.edit_pos == 0 and key == 'backspace':
                mode = None
            elif self.edit_pos == 0 and not mode and key in self._mode_map:
                mode = key
            if self.mode != mode:
                self.mode = mode
                return None

            key = super().keypress(size, key)

            space = (' ', '\t', '\n')
            def char(delta):
                if 0 <= self.edit_pos+delta < len(self.edit_text):
                    return self.edit_text[self.edit_pos+delta]
                return None
            if self._command_map[key] == 'word left':
                if self.edit_pos > 0:
                    while char(-1) in space:
                        self.edit_pos = self.edit_pos - 1
                    while char(-1) and char(-1) not in space:
                        self.edit_pos = self.edit_pos - 1
                    return None
            elif self._command_map[key] == 'word right':
                if self.edit_pos < len(self.edit_text):
                    self.edit_pos = self.edit_pos + 1
                    while char(0) and char(0) not in space:
                        self.edit_pos = self.edit_pos + 1
                    while char(0) in space:
                        self.edit_pos = self.edit_pos + 1
                    return None
            elif key in ('page up', 'page down'):
                (col,row) = self.get_cursor_coords(size)
                assert len(size) == 1
                delta = self.rows(size)
                if key == 'page up':
                    delta = -delta
                (maxcol,) = size
                min_xy = self.position_coords(maxcol, 0)
                max_xy = self.position_coords(maxcol, len(self.edit_text))
                y = row + delta
                if y < min_xy[1]:
                    y = min_xy[1]
                if y > max_xy[1]:
                    y = max_xy[1]
                if row != y and self.move_cursor_to_coords(size, col, y):
                    return None

            return key


    def __init__(self, state):
        self.state = state

        self.search_list = urwid.SimpleFocusListWalker([])

        self._wsearch = urwid.ListBox(self.search_list)
        self._wtitle = urwid.Text('')
        self._wline = ChatWindow.Editor({
            None: ('bold', '> '), # default input
            '/' : ('bold', '/'),  # search mode
            ':' : ('bold', ':'),  # command mode
        })
        self._empty = urwid.SimpleFocusListWalker([])
        chat = self.state.current_chat
        self._wlist = VimListBox(chat if chat else self._empty)

        self._w = urwid.WidgetPlaceholder(self._wlist)
        super().__init__([('pack'    , self._wtitle),
                          (1         , urwid.SolidFill('-')),
                          ('weight',1, self._w),
                          (1         , urwid.SolidFill('-')),
                          ('pack'    , self._wline)])

        urwid.connect_signal(self._wline, 'postchange', self.on_edit_text_changed)
        urwid.connect_signal(self._wline, urwid.ACTIVATE, self.on_edit_active)
        urwid.connect_signal(self._wline, 'editor_mode_changed', self.on_edit_mode_changed)
        urwid.connect_signal(self.state, 'current_contact_changed', self.on_current_contact_changed)
        urwid.connect_signal(self.state.signal, 'receive_message', self.on_new_message)
        urwid.connect_signal(self.state.signal, 'send_message', self.on_new_message)

    @property
    def search_mode(self):
        return self._wline.mode == '/'

    def show_message_info(self, envelope):

        state = self.state

        class DataItem(urwid.WidgetWrap):
            def __init__(self, w, data, do_open = None):
                self._data = data
                self._do_open = do_open
                super().__init__(w)

            def keypress(self, size, key):
                key = super().keypress(size, key)
                if key == 'y':
                    key = None
                    clip.put(state, self._data)
                elif self._do_open and key in ('enter', 'o'):
                    key = None
                    self._do_open(self._data)
                return key

        def fmt(txt, opt=None, key=None):
            if opt:
                if txt:
                    txt = txt + ' '
                txt = txt + '(' + opt + ')'
            if key:
                key += ': '
            l = []
            if key:
                l.append(btxt(key))
            if txt:
                l.append(ntxt(txt))
            return FocusableText(l)

        source = envelope['source']
        msg = get_envelope_msg(envelope)
        try:
            date = datetime.utcfromtimestamp(envelope['timestamp'])
        except ValueError:
            date = datetime.utcfromtimestamp(envelope['timestamp'] / 1000)

        state.show_dialog(VimListBox([
            *[DataItem(fmt(v, key=k), v) for k,v in [
                ('Name   ', get_contact_name(state.signal.get_contact(source))),
                ('Number ', source),
                ('Date   ', date.strftime('%H:%M:%S (%Y-%m-%d)')),
                ('Message', msg),
            ]],

            urwid.Text(btxt('Links'), align='center'),
            *[DataItem(fmt(url), url, state.commands.open_single_url)
              for url in get_urls(msg)],

            urwid.Text(btxt('Attachments'), align='center'),
            *[DataItem(fmt(get_attachment_name(a), opt=get_attachment_type(a)),
                       get_attachment_path(self.state.cfg, a),
                       state.commands.open_file)
              for a in get_envelope_attachments(envelope)]
        ]))

    def on_edit_mode_changed(self, old, new):
        if '/' in (old, new):
            self._w.original_widget = self._wsearch if self.search_mode else self._wlist
            self.search_in_chat()

    def on_edit_text_changed(self, _sender, _old_text):
        if self.search_mode:
            self.search_in_chat()

    def search_in_chat(self):
        if not self.search_mode:
            return

        search_txt = self.get_edit_text()
        def setx(i, txt):
            txt.real_index = i
            return txt
        found = [setx(i, txt)
                 for i, txt in enumerate(self._wlist.body)
                 if search_txt in txt.original_widget.text]
        self.search_list.clear()
        self.search_list.extend(found)

    def on_new_message(self, _envelope):
        self.focus_chatlast()

    def is_focused_input(self):
        return self.focus_position == 4

    def is_focused_chat(self):
        return self.focus_position == 2

    def focus_input(self):
        self.focus_position = 4

    def focus_chat(self):
        self.focus_position = 2

    def focus_chatfirst(self):
        self._w.original_widget.focus_first()

    def focus_chatlast(self):
        self._w.original_widget.focus_last()

    def get_edit_text(self):
        return self._wline.get_edit_text()

    def set_title(self, contact):
        if contact:
            num = contact.get("number")
            if not num:
                num = ', '.join([
                    get_contact_name(self.state.signal.get_contact(number))
                    for number in contact['members']])

            self._wtitle.set_text([('bold', get_contact_name(contact)), ' (', num, ')'])
        else:
            self._wtitle.set_text('')

    def on_current_contact_changed(self, old, current, focus=False):
        self.set_title(current)
        chat = self.state.current_chat
        self._wlist.body = chat if chat else self._empty
        if current:
            self.focus_chatlast()

    def get_current_envelope(self):
        try:
            if self.search_mode:
                return self.search_list[self._wsearch.focus_position].envelope
            return self.state.current_chat[self._wlist.focus_position].envelope
        except (IndexError, AttributeError):
            return None

    def on_edit_active(self, mode, txt):
        if mode == ':':
            space = txt.find(' ')
            cmd, args = (txt[0:space], txt[space+1:]) if space >= 0 else (txt, '')
            self.state.commands.exec(cmd.lower(), args)
        elif mode == '/':
            pass
        elif txt.strip(' ') != '':
            self.state.send_message(txt)

    def keypress(self, size, key):
        key = super().keypress(size, key)

        if self.state.current_chat and self.is_focused_chat():
            key = self._w.original_widget.keypress(size, key)
            envelope = self.get_current_envelope()
            if key in ('enter', 'l'):
                if self.search_mode:
                    real_index = self.search_list[self._wsearch.focus_position].real_index
                    self._wline.set_edit_text(txt)
                    self._wlist.focus_position = real_index
                else:
                    self.state.commands.open_attach(envelope) or self.state.commands.open_url(envelope)
            elif key == 'o':
                self.state.commands.open_url(envelope) or self.state.commands.open_attach(envelope)
            elif key == 'y':
                txt = get_envelope_msg(envelope)
                clip.put(self.state, txt)
            elif key in ('d', 'delete'):
                if self.search_mode:
                    item = self.search_list[self._wsearch.focus_position]
                    real_index = item.real_index
                    del self.search_list[self._wsearch.focus_position]
                    del self.state.current_chat[real_index]
                else:
                    del self.state.current_chat[self._wlist.focus_position]
            elif key == 'i':
                self.show_message_info(envelope)
            elif key == 'q':
                # TODO: quote (https://github.com/AsamK/signal-cli/issues/151)
                pass
        return key

urwid.register_signal(ChatWindow.Editor, ChatWindow.Editor.signals)

# #############################################################################
# MainWindow
# #############################################################################

class MainWindow(urwid.Frame):

    def __init__(self, state):
        self.state = state

        # ui
        self._wcontacts = ContactsWindow(self.state)
        self._wchat = ChatWindow(self.state)
        self._wstatus = urwid.Text("...")
        self._wnotify_count = urwid.Text("...")
        self._status_data = None

        self._wcontext = urwid.Columns([('weight', 1, NiceBox(self._wcontacts)),
                                        ('weight', 3, NiceBox(self._wchat))],
                                       dividechars=0, focus_column=0)
        super().__init__(self._wcontext,
                         footer=urwid.Columns([self._wstatus, ('pack', self._wnotify_count)]))

        # signals
        urwid.connect_signal(self.state, 'current_contact_changed', self.on_current_contact_changed)
        urwid.connect_signal(self.state, 'status_changed', self.set_status)
        urwid.connect_signal(self.state, 'notification_changed', self.set_status)
        urwid.connect_signal(self.state, 'error_changed', self.set_status)
        urwid.connect_signal(self.state.cfg, 'changed', self.on_cfg_changed)
        urwid.connect_signal(self._wcontacts, 'notify_count_changed', self.on_notify_count_changed)

    def update_program_title(self):
        contact = self.state.current_contact
        cnt = self._wcontacts.notify_count
        self.state.set_program_subtitle(
            'Message ' + get_contact_name(contact) if contact else None,
            prefix = '(' + str(cnt) + ' new)' if cnt else None)

    def set_status(self, txt, data = None):
        self._wstatus.set_text(txt)
        self._status_data = data

    @property
    def focus_position(self):
        assert super().focus_position == 'body'
        if len(self._wcontext.contents) == 2 and self._wcontext.focus_position == 0:
            return 'contacts'
        elif self._wchat.is_focused_chat():
            return 'chat'
        else:
            assert self._wchat.is_focused_input()
            return 'input'

    @focus_position.setter
    def focus_position(self, new):
        self.on_focus_changing(new)
        body_pos = 0 if len(self._wcontext.contents) == 1 else 1
        if self.focus_position == new:
            pass
        elif new == 'contacts':
            self._wcontext.set_focus(0)
        elif new == 'chat':
            self._wcontext.set_focus(body_pos)
            self._wchat.focus_chat()
        elif new == 'input':
            self._wcontext.set_focus(body_pos)
            self._wchat.focus_input()
        else:
            assert new in ('contacts', 'chat', 'input')

    def on_focus_changing(self, new):
        is_hidden = len(self._wcontext.contents) == 1
        can_be_hidden = not new == 'contacts' and self.state.cfg.contacts_autohide
        if not is_hidden == can_be_hidden:
            self._toggle_contacts()

    def _toggle_contacts(self):
        if len(self._wcontext.contents) == 2:
            self._wcontext.contents.clear()
            self._wcontext.contents.append(
                (NiceBox(self._wchat),
                 self._wcontext.options(width_amount=3)))
        else:
            self._wcontext.contents.insert(0,
                (NiceBox(self._wcontacts),
                 self._wcontext.options(width_amount=1)))

    def show_help_pop_up(self):
        # TODO
        self.state.show_dialog(VimListBox([
            urwid.Text(btxt("Keybindings")),
            urwid.Text(btxt("Commands"))
        ]))

    def on_current_contact_changed(self, old, current, focus=False):
        if self._status_data is self.state.current_contact:
            self.state.set_status('')
        self.update_program_title()

        if focus:
            self.focus_position = 'input'

    def on_cfg_changed(self, key, val):
        if key == 'contacts_autohide':
            self.on_focus_changing(self.focus_position)

    def on_notify_count_changed(self, count):
        self._wnotify_count.set_text(btxt(str(count)))
        self.update_program_title()

    def keypress(self, size, key):
        key = super().keypress(size, key)

        if key in (':', '/'):
            self.focus_position = 'input'
            self._wchat._wline.mode = key
        elif key == '?':
            self.show_help_pop_up()
        elif update_focus(self._command_map[key],
                          [{self: x} for x in ['contacts', 'chat', 'input']]):
            pass
        else:
            return key

        return None

# #############################################################################
# state
# #############################################################################

class State:
    signals = ['current_contact_changed', 'status_changed',
               'notification_changed', 'error_changed', 'dialog_finished']

    def __init__(self, cfg):
        self.signal = Signal(get_backend_desc(cfg), cfg.username)
        self.cfg = cfg
        self.chats = {} # mapping get_contact_hash() to urwid.SimpleFocusListWalker
        self.current_contact = None
        self.loop = None
        self.daemon = None

        self.commands = Commands(self)

        urwid.connect_signal(self.signal, 'receive_message', self.on_receive_message)
        urwid.connect_signal(self.signal, 'send_message', self.on_send_message)

    @property
    def current_chat(self):
        return self.get_chat_for_contact(self.current_contact)

    def start_daemon(self, loop):
        if not self.cfg.signald:
            self.daemon = signalcli_daemon(self.cfg.username, loop, self.signal)
        elif self.cfg.signald == 'socat':
            self.daemon = signald_socat(self.cfg.username, loop, self.signal, self.cfg.signald_sock)
        else:
            self.daemon = signald_netcat_openbsd(self.cfg.username, loop, self.signal, self.cfg.signald_sock)

    def send_message(self, message, attachments=None, contact=None):
        if not contact:
            contact = self.current_contact
        if not contact:
            self.set_error('error: no contact selected, cannot send message')
            return False
        if not (message or attachments):
            return False

        if not attachments:
            attachments = []

        attachment_paths = [os.path.expanduser(attachment) for attachment in attachments]
        for i, a in enumerate(attachment_paths):
            if not os.path.exists(a):
                self.set_error('Attached file ' + attachments[i] + ' does not exist.')
                logging.warning('send_message: Attached file(s) does not exist.')
                return False

        self.daemon.send_message(contact, message, attachment_paths)
        return True

    def set_program_subtitle(self, subtitle, prefix=None):
        my_contacts = list(filter(lambda x: x.get('number') == self.cfg.username, self.signal.contacts()))
        my_name = get_contact_name(my_contacts[0]) if len(my_contacts) == 1 else self.cfg.username
        title = ''
        if prefix:
            title = prefix + ' '
        title = title + 'scli ' + my_name
        if subtitle:
            title += ': ' + subtitle
        try:
            self.loop.screen.write('\x1b]2;' + title + '\x07')
        except AttributeError:
            pass

    def set_current_contact(self, new, focus=False):
        old = self.current_contact
        self.current_contact = new
        urwid.emit_signal(self, 'current_contact_changed', old, new, focus)

    def set_status(self, status, data=None):
        urwid.emit_signal(self, 'status_changed', status, data)

    def set_notification(self, notif, data=None):
        urwid.emit_signal(self, 'notification_changed', notif, data)

    def set_error(self, err):
        urwid.emit_signal(self, 'error_changed', err)

    def show_dialog(self, w):
        self.loop.widget.show_pop_up(w, self)

    def get_chat_for_contact(self, contact):
        if not contact:
            return None

        contact_hash = hash_contact(contact)
        if contact_hash not in self.chats:
            self.chats[contact_hash] = urwid.SimpleFocusListWalker([])

        return self.chats[contact_hash]

    def get_chat_for_envelope(self, envelope):
        contact = get_envelope_contact(envelope, self.signal)
        return self.get_chat_for_contact(contact)

    def on_send_message(self, envelope):
        self.print_sent_message(envelope)

    def on_receive_message(self, envelope):
        msg = get_envelope_msg(envelope)
        sender = get_envelope_contact(envelope, self.signal)
        contact_name = get_contact_name(sender)

        if msg is None:
            logging.info('NOT_A_MESSAGE:%s', envelope)
            return
        logging.info('MESSAGE:%s', envelope)

        if sender != self.current_contact:
            notif = 'New message from ' + contact_name + ': "' + msg + '"'
            self.set_notification(notif, sender)

        formatted_message = self.print_received_message(envelope)
        self.commands.send_notification(contact_name, to_txt(formatted_message))

    def format_msg(self, message):
        message = '\n'.join(textwrap.wrap(message, width=self.cfg.wrap_at))

        if not self.cfg.use_formatting:
            return ntxt(message)

        i, m = 0, []
        while i < len(message):
            c = message[i]
            if c in FORMAT_MAP:
                try:
                    end = message[i+1:].index(c)
                    sub = message[i+1:i+1+end]
                    m.append(c)
                    m.append((FORMAT_MAP[c], sub))
                    m.append(c)
                    i = i + 2 + end
                except ValueError:
                    m.append(c)
                    i = i + 1
            else:
                m.append(c)
                i = i + 1

        if not m:
            m = " "
        return m

    def print_received_message(self, envelope):
        source = envelope['source']
        is_group = is_envelope_group_message(envelope)
        attachments = get_envelope_attachments(envelope)

        txt = [btxt('>> ')]
        if is_group or self.cfg.show_names:
            contact = self.signal.get_contact(source)
            if contact:
                txt.append(ibtxt(get_contact_name(contact)))
            else:
                txt.append(btxt(source))
            txt.append(btxt(' | '))

        message = self.format_msg(get_envelope_msg(envelope))
        attachments = get_envelope_attachments(envelope)

        if attachments != []:
            attachments_txt = ', '.join([
                get_attachment_name(attachment) + ' (' + str(i) + ')'
                for i, attachment in enumerate(attachments)])
            txt.append(ntxt('[attached: ' + attachments_txt + '] '))

        txt.append(message)
        wtxt = FocusableText(txt)
        wtxt.envelope = envelope
        self.get_chat_for_envelope(envelope).append(wtxt)

        return txt[1:]

    def print_sent_message(self, envelope):
        message = self.format_msg(get_envelope_msg(envelope))
        attachments = get_envelope_attachments(envelope)

        txt = []
        if len(attachments) > 0:
            anames = ', '.join([os.path.basename(attachment) for attachment in attachments])
            txt.append(ntxt('[attached: '))
            txt.append(itxt(anames))
            txt.append(ntxt('] '))
            txt.append(ntxt(message))
        else:
            txt.append(message)

        if self.cfg.one_sided:
            align = 'left'
            txt.insert(0, btxt('<< '))
            if self.cfg.show_names:
                txt.insert(1, btxt('You | '))
        else:
            align = 'right'
            if self.cfg.show_names:
                txt.append(btxt(' | You'))
            txt.append(btxt(" <<"))

        wtxt = FocusableText(txt, align=align)
        wtxt.envelope = envelope
        self.get_chat_for_envelope(envelope).append(wtxt)

    def save_history(self):
        if not self.cfg.save_history:
            return

        with open(SCLI_HISTORY_FILE, 'w') as history_file:
            envelopes = [x.envelope for vals in self.chats.values() for x in vals]
            items = {'envelopes': envelopes}
            history_file.write(json.dumps(items))

    def load_history(self):
        if not self.cfg.save_history or not os.path.exists(SCLI_HISTORY_FILE):
            return

        with open(SCLI_HISTORY_FILE, 'r') as history_file:
            history = json.load(history_file)
            for envelope in history['envelopes']:
                if is_envelope_outgoing(envelope):
                    self.print_sent_message(envelope)
                else:
                    self.print_received_message(envelope)

urwid.register_signal(State, State.signals)


# #############################################################################
# PopUpTarget
# #############################################################################

class PopUpTarget(urwid.WidgetPlaceholder):

    def __init__(self, widget):
        super().__init__(widget)

    # if notify, it must accept the signal 'dialog_finished' with 2 parameter:
    # 'accepted' (True or False) and 'result' (unknown)
    def show_pop_up(self, widget, notify = None,
                    width = ('relative', 75), height = ('relative', 65)):
        org = self.original_widget

        def on_pop_up_closed(accepted, result):
            self.original_widget = org
            if notify:
                urwid.emit_signal(notify, 'dialog_finished', accepted, result)

        class PopUpWrapper(NiceBox):
            def __init__(self, widget, buttons=True):
                self._widget = widget
                self._widget.result = None

                if buttons:
                    btn_ok = urwid.Button('OK', self.close, True)
                    btn_cancel = urwid.Button('Cancel', self.close, False)
                    b = urwid.GridFlow([btn_ok, btn_cancel], 10, 1, 0, 'right')
                    w = urwid.Pile([widget, ('pack',b)])
                    super().__init__(w)
                    self._order = [ { w: 0 }, { w: 1, b: 0 }, { w: 1, b: 1 } ]
                else:
                    super().__init__(widget)
                    self._order = [ { widget: 0 } ]

            def close(self, btn=None, status=False):
                result = None
                if status:
                    result = self._widget.result
                on_pop_up_closed(status, result)

            def keypress(self, size, key):
                key = super().keypress(size, key)

                if update_focus(self._command_map[key], self._order):
                    return None
                if key == 'q':
                    self.close()
                    return None
                return key

        self.original_widget = urwid.Overlay(PopUpWrapper(widget),
                                             org,
                                             align='center',
                                             valign='middle',
                                             width=width,
                                             height=height)


# #############################################################################
# main
# #############################################################################

def parse_cfg_file(cfg_file_path):
    vars = {}
    cfg_file_path = os.path.expanduser(cfg_file_path)
    if os.path.exists(cfg_file_path):
        with open(cfg_file_path) as cfg_file:
            for line in cfg_file:
                if not line.startswith('#') and line.strip() != "":
                    name, var = line.partition("=")[::2]
                    vars[name.strip().replace('-', '_')] = var.strip()
    elif cfg_file_path != SCLI_CFG_FILE and cfg_file_path != "":
        print('Given config file not found: ' + cfg_file_path, file=sys.stderr)
        sys.exit(2)

    return vars

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--config-file',
        type=str,
        default=SCLI_CFG_FILE,
        help='Config file. Configs in this file overrides every other config ' +
             'supplied by command line. (Default: ' + SCLI_CFG_FILE + ')'
    )
    parser.add_argument('-u', '--username',
        type=str,
        help='Phone number starting with "+" followed by country code.'
    )
    parser.add_argument('-n', '--enable-notifications',
        default=False,
        action='store_true',
        help='Enable desktop notifications. (Also see --notification-command)'
    )
    parser.add_argument('-N', '--notification-command',
        type=str,
        default="notify-send scli '%s - %m'",
        help='The command to run when a new message arrives. %%m is replaced ' +
             'with the message, %%s is replaced with the sender. (Default is ' +
             '"notify-send scli \'%%s - %%m\''
    )
    parser.add_argument('-o', '--open-command',
        type=str,
        default='xdg-open "%u"',
        help='File/URL opener command. %%u is replaced with the path. ' +
             '(Default is "xdg-open %%u")'
    )
    parser.add_argument('-e', '--editor-command',
        type=str,
        default='$EDITOR',
        help='A text editor command to edit your messages externally.'
    )
    parser.add_argument('-G', '--clipboard-get-command',
        type=str,
        default="",
        help='A command that returns a valid file path(s). When user calls ' +
             '`:attachClip` or `:c`, this command is executed and the returned ' +
             'file(s) will be added as attachment(s). The command should return ' +
             'one absolute file path per each line. (Default uses `xclip`)'
    )
    parser.add_argument('-P', '--clipboard-put-command',
        type=str,
        default="",
        help='A command that puts given text to clipboard. %%s will be replaced ' +
             'with the text. (Default uses `xclip`.'
    )
    parser.add_argument('-s', '--save-history',
        default=False,
        action='store_true',
        help='Enable saving history. History is saved as plain text. ' +
             '(Disabled by default.)'
    )
    parser.add_argument('-f', '--use-formatting',
        default=False,
        action='store_true',
        help='Use /italic/, *bold*, ~strikethrough~, _underline_ formatting in ' +
             'messages. (Disabled by default.)'
    )
    parser.add_argument('-w', '--wrap-at',
        type=int,
        default=300,
        help='Wrap messages at given column.'
    )
    parser.add_argument('--one-sided',
        default=False,
        action='store_true',
        help='Show messages aligned to one side in message list. ' +
             '(Disabled by default.)'
    )
    parser.add_argument('--show-names',
        default=False,
        action='store_true',
        help='Show contact names even in message list even if it is one-to-one ' +
             'conversation. (Disabled by default.)'
    )
    parser.add_argument('--contacts-autohide',
        default=False,
        action='store_true',
        help='Autohide the contacts pane when it loses focus. (Disabled by default)'
    )
    parser.add_argument('--no-daemon',
        action='store_true',
        help='Not really useful.'
    )
    parser.add_argument('--no-italics',
        default=False,
        action='store_true',
        help="don't use italics fonts (some fonts don't have those glyphs)"
    )
    parser.add_argument('--no-mouse',
        default=False,
        action='store_true',
        help="disable terminal mouse support"
    )
    parser.add_argument('--signald-sock',
        default='/var/run/signald/signald.sock',
        type=str,
        help='path to signald socket'
    )
    parser.add_argument('--signald',
        default=None,
        type=str,
        help="use SIGNALD={socat,netcat} to connect to signald socket instead " +
             "of spawning signal-cli; please note, that 'netcat' denotes " +
             "OpenBSD's netcat (must support '-U' for unix domain sockets)"
    )
    parser.add_argument('--debug',
        default=False,
        action='store_true'
    )

    cfg = parser.parse_args()
    file_cfg = parse_cfg_file(cfg.config_file)
    for key, val in file_cfg.items():
        attr = getattr(cfg, key)
        if isinstance(attr, bool):
            setattr(cfg, key, val.lower() in ['true', 't', 'yes', 'y'])
        elif isinstance(attr, int):
            setattr(cfg, key, int(val))
        else:
            setattr(cfg, key, val)

    if not os.path.exists(SCLI_DATA_FOLDER):
        try:
            os.makedirs(SCLI_DATA_FOLDER)
        except OSError as exc:
            if not (exc.errno == errno.EEXIST and os.path.isdir(SCLI_DATA_FOLDER)):
                print("Can't create data directory.", file=sys.stderr)
                sys.exit(3)

    if cfg.debug:
        logging.basicConfig(filename=SCLI_LOG_FILE, level=logging.DEBUG)
    else:
        logging.basicConfig(filename=SCLI_LOG_FILE, level=logging.CRITICAL)

    if cfg.signald and cfg.signald not in ('socat','netcat'):
        print("error: SIGNALD must be either 'socat' or 'netcat'", file=sys.stderr)
        sys.exit(1)

    if not cfg.username:
        ulist = get_backend_desc(cfg).list_users()

        if not ulist:
            print("Couldn't find any linked device.", file=sys.stderr)
            sys.exit(1)
        elif len(ulist) == 1:
            cfg.username = ulist[0]
        else:
            print("Use one of these:", file=sys.stderr)
            for u in ulist:
                print("\tscli --username=" + u, file=sys.stderr)
            sys.exit(1)

    if cfg.no_italics:
        global PALETTE
        global ibtxt
        global itxt
        PALETTE = PALETTE_NO_ITALICS
        ibtxt = lambda txt: ('bold', txt)
        itxt = lambda txt: ('bold', txt)

    state = State(ObservableConfig(cfg))
    window = MainWindow(state)

    loop = urwid.MainLoop(PopUpTarget(window), palette=PALETTE, handle_mouse=not cfg.no_mouse)

    state.loop = loop
    state.set_program_subtitle(None)
    state.load_history()
    atexit.register(state.save_history)

    if not cfg.no_daemon:
        state.start_daemon(loop)

    loop.run()

if __name__ == "__main__":
    main()
